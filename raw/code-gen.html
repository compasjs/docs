
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0"/>
        <title>Code gen</title>
        <meta name="description" content="Compas old docs"/>
        <link rel="canonical" href="https://pre.compasjs.com/raw/code-gen.html"/>
        <style>
            body {margin: 5% auto; background: #f2f2f2; color: #444444; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.8; text-shadow: 0 1px 0 #ffffff; max-width: 73%;}
            pre, code {background: white;}
            pre {padding-left: 2px; line-height: 1.2; }
            code {margin-left: 2px; margin-right: 2px; }
            a {border-bottom: 1px solid #444444; color: #444444; text-decoration: none;}
            a:hover {border-bottom: 0;}
            .hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0}.hljs,.hljs-subst{color:#444}.hljs-comment{color:#888}.hljs-attribute,.hljs-doctag,.hljs-keyword,.hljs-meta-keyword,.hljs-name,.hljs-selector-tag{font-weight:700}.hljs-deletion,.hljs-number,.hljs-quote,.hljs-selector-class,.hljs-selector-id,.hljs-string,.hljs-template-tag,.hljs-type{color:#800}.hljs-section,.hljs-title{color:#800;font-weight:700}.hljs-link,.hljs-regexp,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#bc6060}.hljs-literal{color:#78a960}.hljs-addition,.hljs-built_in,.hljs-bullet,.hljs-code{color:#397300}.hljs-meta{color:#1f7199}.hljs-meta-string{color:#4d99bf}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}
        </style>
    </head>
    <body>
    <header>
        <nav><a href="https://pre.compasjs.com/index.html">Compas</a> > <a href="https://pre.compasjs.com/raw/index.html">Old docs</a></nav>
    </header>
    <main>
    <article>
        <h1 id="code-generation">Code generation</h1>
<h2 id="the-basics">The basics</h2>
<p>The code generators is build using a few different items:</p>
<ul>
<li>TypeBuilder: The base for all types. Contains various utilities like
<code>optional</code> and <code>docs</code>.</li>
<li>TypeCreator: Creates instances of classes that extends TypeBuilder. Often
abbreviated to <code>T</code>.</li>
<li>App: Entry point of code generation. Stores all &#39;added&#39; types and makes sure
to pass them to the generators.</li>
</ul>
<p>All constructed types are put in to groups and can be named or unnamed. Types
directly registered to the app should all have a name. The group is managed when
constructing a TypeCreator, while the names are passed to the different methods
of the TypeCreator, while instantiating a TypeBuilder.</p>
<p>A small example:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> T = <span class="hljs-keyword">new</span> TypeBuilder(<span class="hljs-string">&quot;todo&quot;</span>);
app.add(T.bool(<span class="hljs-string">&quot;completed&quot;</span>)); <span class="hljs-comment">// Fully qualified name of `TodoCompleted`</span>
app.add(T.bool()); <span class="hljs-comment">// Error: no name provided</span></code></pre>
<h2 id="the-app">The App</h2>
<p>The app is constructed with <code>await App.new()</code> and after that ready to generate
any number of times. It provides a few methods for adding types and doing
generation. Normal types can be added with <code>app.add()</code>. This accepts any number
of parameters. Another way is calling <code>app.extend()</code> with a full structure. This
structure is not yet stable between releases and thus not documented. However a
structure created by a specific lbu version, can always be consumed by the same
version. The use case for <code>app.extend</code> is two fold:</p>
<ul>
<li>Used by frontend/app teams with the fetched structure</li>
<li>Useable for backend/frontend/app teams for adding external api&#39;s converted via
the OpenAPI importer (<code>convertOpenAPISpec</code>)</li>
</ul>
<p>When all needed types are added, multiple calls can be done to <code>app.generate</code>. A
call to <code>app.generate</code> looks something like the following:</p>
<pre><code class="language-javascript">app.generate({
  <span class="hljs-attr">dumpStructure</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Enable when developing the backend</span>
  <span class="hljs-attr">enabledGenerators</span>: [<span class="hljs-string">&quot;types&quot;</span>, <span class="hljs-string">&quot;validator&quot;</span>, <span class="hljs-string">&quot;router&quot;</span>], <span class="hljs-comment">// or &quot;apiClient&quot;, &quot;reactQuery&quot;, &quot;sql&quot;</span>
  <span class="hljs-comment">// When groups are not provided they are all enabled.</span>
  <span class="hljs-comment">// The code-generator is smart enough to resolve references across groups</span>
  <span class="hljs-attr">enabledGroups</span>: [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;orMore&quot;</span>, <span class="hljs-string">&quot;groups&quot;</span>],
  <span class="hljs-attr">useTypescript</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// generates typescript types</span>
  <span class="hljs-attr">outputDirectory</span>: <span class="hljs-string">&quot;./relative/path/from/root&quot;</span>,
});</code></pre>
<h2 id="the-generators">The generators</h2>
<p>There are various generators provided by the base code-gen package. Some do
generate for all available types, others have specific calls that need to be
done. See further in this file for a more extensive information.</p>
<ul>
<li><p><strong>Types</strong>: generates a <code>types.js</code> or <code>types.ts</code> file where all &#39;added&#39; types
are put. It also generates an <code>_Input</code> variant, which basically represents the
value before it passes through a validator.</p>
</li>
<li><p><strong>Validator</strong>: generate validator functions for all types. This does all the
conversions, and places default values.</p>
</li>
<li><p><strong>Router</strong>: generate a router with appropriate validator calls. See below for
more information.</p>
</li>
<li><p><strong>ApiClient</strong> and <strong>ReactQuery</strong>: Create api clients for the generated router</p>
</li>
<li><p><strong>Sql</strong>: Generate Postgres queries for <code>Select</code>, <code>Insert</code>,<code>Update</code>,<code>Upsert</code>
and <code>Delete</code> statements.</p>
</li>
</ul>
<h2 id="the-types">The Types</h2>
<p>The code-gen package comes with a number of default types. Below a list of them
with a short description, some extra functionality provided by a generator, and
how you can create it via the TypeCreator (<code>T</code>).</p>
<p><strong>Basic</strong>:</p>
<ul>
<li><p><strong>Boolean</strong>: created with <code>T.bool()</code> it represents either true or false.
However by using the <code>.oneOf</code> function it can represent a single state. The
validator adds support for converting incoming strings like <code>&quot;true&quot;</code> via the
<code>.convert()</code> method.</p>
</li>
<li><p><strong>Number</strong>: created with <code>T.number()</code> it represents an integer. Via <code>.float()</code>
enforceable to also accept floating point numbers. It is also possible to
parse from string with the validators (<code>.convert()</code>) and providing minimum and
maximum values via <code>.min()</code> and <code>.max()</code>.</p>
</li>
<li><p><strong>String</strong>: created with <code>T.string()</code>. The validator has various utilities
build in for this type as well.</p>
<ul>
<li><code>.min()</code> and <code>.max()</code> to enforce a length. The default length is one (1).</li>
<li><code>.trim()</code>, <code>.lowercase()</code> and <code>.uppercase()</code> for sanitizing some data</li>
<li><code>.pattern()</code> to check with a regular expression</li>
<li><code>.oneOf()</code> to enforce specific values. This is also the way to create an
&#39;enum&#39;-like.</li>
<li><code>.isOptional()</code> allow empty and undefined values. Empty strings are
automatically converted to undefined values.</li>
</ul>
</li>
<li><p><strong>Object</strong>: created with <code>T.object()</code> supports string keys and other
TypeBuilders as values.</p>
</li>
<li><p><strong>Array</strong>: created by <code>T.array()</code> represents a &#39;single&#39; type array. The value
type can be specified with <code>.values()</code></p>
</li>
<li><p><strong>AnyOf</strong>: created with <code>T.anyOf</code> represents any of the provided types added
by <code>.values()</code>. Note that when validating, they are evaluated from left to
right.</p>
</li>
<li><p><strong>Generic</strong>: created with <code>T.generic()</code> a generic object, where both <code>.keys()</code>
and <code>.values()</code> should be specified.</p>
</li>
<li><p><strong>Any</strong>: created with <code>T.any</code>, represents any type.</p>
</li>
<li><p><strong>Date</strong>: created with <code>T.date()</code>, accepts ISO8601 strings while validating
and returns a JS Date object</p>
</li>
<li><p><strong>Uuid</strong>: created with <code>T.uuid()</code> is a type based on <code>T.string()</code> using a
regular expression.</p>
</li>
<li><p><strong>Reference</strong>: created with <code>T.reference()</code>, is a reference to a &#39;named&#39; type.
This type can be used in all cases where a TypeBuilder is accepted.</p>
</li>
<li><p><strong>File</strong>: created with <code>T.file()</code> has its use with the router generator for
file uploads.</p>
</li>
</ul>
<p><strong>Advanced</strong>:</p>
<ul>
<li><p><strong>Optional</strong>: created with <code>T.optional()</code> can make an optional copy of the
passed in type.</p>
</li>
<li><p><strong>Omit</strong>: created with <code>T.omit()</code> allows to remove a subset of keys from a
passed in object.</p>
</li>
<li><p><strong>Pick</strong>: created with <code>T.pick()</code> allows pick a subset of keys from the passed
in obejct.</p>
</li>
<li><p><strong>Searchable</strong>: created with <code>T.searchable()</code> makes a copy of the provided
value and returns it as sql searchable.</p>
</li>
</ul>
<p><strong>Relations</strong>:</p>
<ul>
<li>On <code>T.object()</code> add method <code>.relations()</code></li>
<li><code>T.oneToMany(&quot;key1&quot;, reference)</code>: (1) side of 1 - many</li>
<li><code>T.manyToOne(&quot;key2&quot;, reference, &quot;key1&quot;)</code>: (m) side of many - 1. Containers
reference to reference-&gt;key1. Never dangling</li>
<li><code>T.oneToOne(&quot;key3&quot;, reference, &quot;key1&quot;)</code>: (1) side of 1 - 1. Contains reference
to reference-&gt;key1. Never dangling. Other side automatically filled in.</li>
<li><code>T.manyToOne(&quot;key2&quot;, reference, &quot;key1&quot;).optional()</code>: (m) side of many - 1.
Containers reference to reference-&gt;key1. May dangle</li>
<li><code>T.oneToOne(&quot;key3&quot;, reference, &quot;key1&quot;).optional()</code>: (1) side of 1 - 1.
Contains reference to reference-&gt;key1. May dangle. Other side automatically
filled in</li>
</ul>
<h2 id="inferred-types">Inferred types</h2>
<p>Some types can be inferred and don&#39;t need the full method chain like
<code>T.object().keys()</code>. Inferred types can only be used with &#39;non-named&#39; types.</p>
<p>Some examples and their <code>T.xx</code> counter parts</p>
<p>Booleans:</p>
<pre><code class="language-javascript">app.add(<span class="hljs-literal">true</span>); <span class="hljs-comment">// T.bool().oneOf(true)</span>
app.add(<span class="hljs-literal">false</span>); <span class="hljs-comment">// T.bool().oneOf(false)</span></code></pre>
<p>Numbers:</p>
<pre><code class="language-javascript">app.add(<span class="hljs-number">5</span>); <span class="hljs-comment">// T.number().oneOf(5)</span></code></pre>
<p>Strings:</p>
<pre><code class="language-javascript">app.add(<span class="hljs-string">&quot;various&quot;</span>); <span class="hljs-comment">// T.string().oneOf(&quot;various&quot;)</span></code></pre>
<p>Objects:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// The following won&#x27;t work, as top level calls should be named</span>
app.add({ <span class="hljs-attr">foo</span>: T.bool() }); <span class="hljs-comment">// Error</span>
app.add(
  T.object(<span class="hljs-string">&quot;nested&quot;</span>).keys({
    <span class="hljs-comment">// inferring works recursive and almost everywhere a TypeBuilder should be provided</span>
    <span class="hljs-attr">myString</span>: <span class="hljs-string">&quot;various&quot;</span>,
    <span class="hljs-attr">nestedObject</span>: {
      <span class="hljs-attr">qualified</span>: T.bool(),
      <span class="hljs-attr">staticAmount</span>: <span class="hljs-number">5</span>,
    },
  }),
);</code></pre>
<p>Arrays:</p>
<pre><code class="language-javascript">app.add([T.string()]); <span class="hljs-comment">// Error, top level types should be named</span>
app.add(
  T.object(<span class="hljs-string">&quot;name&quot;</span>).keys({
    <span class="hljs-attr">numberArray</span>: [T.number()], <span class="hljs-comment">// T.array().values(T.number().integer())</span>
    <span class="hljs-attr">objectArray</span>: [
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;bar&quot;</span>,
        <span class="hljs-attr">value</span>: T.bool(),
      },
    ],
  }),
);</code></pre>
<h3 id="generator-integrations">Generator integrations</h3>
<p>Some generators work stand alone, some always require another generator to be
enabled. The following is a complete integration list:</p>
<ul>
<li>The <code>type</code> generator is required by all other generators. In case of JSDoc
types, they just use them. When <code>useTypescript</code> is provided, they are used so
that Typescript understands it.</li>
<li>The <code>router</code> generator expects the <code>validator</code> generator to be enabled. The
validators are automatically inserted to validate route and query parameters,
but also the body if needed.</li>
<li>The <code>reactQuery</code> generator expects the <code>apiClient</code> to be enabled. The
generated hooks will internally call the functions provided by the
<code>apiClient</code>.</li>
<li>The <code>apiClient</code> assumes validators are enabled when <code>isNodeServer</code> is provided
to <code>App#generate</code>. This automatically enables response validation and
conversion of errors to <code>AppError</code>. External api&#39;s used by the current
application should be generated with separate <code>App#generate</code> calls.</li>
</ul>

    </article>
    
    </main>
    <footer>
        <nav><a href="https://pre.compasjs.com/index.html">Compas</a> > <a href="https://pre.compasjs.com/raw/index.html">Old docs</a></nav>
    </footer>
    </body>
</html>
  