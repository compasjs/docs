
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0"/>
        <title>Store</title>
        <meta name="description" content="Compas old docs"/>
        <link rel="canonical" href="https://compasjs.com/raw/store.html"/>
        <style>
            body {margin: 5% auto; background: #f2f2f2; color: #444444; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.8; text-shadow: 0 1px 0 #ffffff; max-width: 73%;}
            pre, code {background: white;}
            pre {padding-left: 2px; line-height: 1.2; }
            code {margin-left: 2px; margin-right: 2px; }
            a {border-bottom: 1px solid #444444; color: #444444; text-decoration: none;}
            a:hover {border-bottom: 0;}
            .hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0}.hljs,.hljs-subst{color:#444}.hljs-comment{color:#888}.hljs-attribute,.hljs-doctag,.hljs-keyword,.hljs-meta-keyword,.hljs-name,.hljs-selector-tag{font-weight:700}.hljs-deletion,.hljs-number,.hljs-quote,.hljs-selector-class,.hljs-selector-id,.hljs-string,.hljs-template-tag,.hljs-type{color:#800}.hljs-section,.hljs-title{color:#800;font-weight:700}.hljs-link,.hljs-regexp,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#bc6060}.hljs-literal{color:#78a960}.hljs-addition,.hljs-built_in,.hljs-bullet,.hljs-code{color:#397300}.hljs-meta{color:#1f7199}.hljs-meta-string{color:#4d99bf}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}
        </style>
    </head>
    <body>
    <header>
        <nav><a href="https://compasjs.com/index.html">Compas</a> > <a href="https://compasjs.com/raw/index.html">Old docs</a></nav>
    </header>
    <main>
    <article>
        <h1 id="store">Store</h1>
<p>The store package provides various wrappers that combine Postgres and Minio, for
persisting data.</p>
<h2 id="postgres">Postgres</h2>
<p>The main entrypoint for setting up a postgres connection is by using
<code>newPostgresConnection</code>. This will use environment variables as specified in
<a href="/env.md">environment</a>, and return a new postgres connection based on the
<a href="https://npmjs.com/packages/postgres">postgres</a> package.</p>
<h3 id="testing">Testing</h3>
<p>For integration testing purposes the package exports
<code>createTestPostgresDatabase</code> and <code>cleanupTestPostgresDatabase</code>. While creating a
test database, all connections to the default database are dropped, a copy is
made and then all data is truncated. This ensures a clean slate for every test
suite.</p>
<h2 id="minio">Minio</h2>
<p>The minio connector can be used to persist files easily. This starts with
calling <code>newMinioClient</code> to initialize the client. After that <code>ensureBucket</code> can
be used to create a bucket if not exists. <code>removeBucket</code> and
<code>removeBucketAndObjectsInBucket</code> are used to delete a bucket, where the latter
will also forcefully remove any object left in the bucket. To get insight
<code>listObjects</code> is available and will collect all objects and return them as an
array.</p>
<h2 id="migrations">Migrations</h2>
<p>This is a forward only, repeatable supported migration tool. In other words, no
&#39;down&#39; scripts, and repeatable migrations will run when they are changed.</p>
<p>To achieve that the following structure is expected:</p>
<ul>
<li>A top level <code>migrations</code> directory</li>
<li>Migration files follow this naming pattern <code>000-r-name-of-migration.sql</code>.<ul>
<li>Where <code>-r</code> is optional, and <code>000</code> is incremented and used as a sorting key</li>
</ul>
</li>
<li>A special handling for <code>namespaces.txt</code> file in the migrations directory.<ul>
<li>A single <code>import()</code>-able package per line</li>
<li>The imported package should export a
<code>export const migrations = /path/to/migrations</code></li>
<li>Note that <code>@lbu/store</code> is automatically added as a namespace</li>
</ul>
</li>
</ul>
<h3 id="usage">Usage</h3>
<p>The following script taken from this repository and provided in the template
should be all that you need. Run <code>yarn lbu migrate</code> and the thing should run,
provided that you already had a working database connection in this project.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { mainFn } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@compas/stdlib&quot;</span>;
<span class="hljs-keyword">import</span> {
  getMigrationsToBeApplied,
  newMigrateContext,
  newPostgresConnection,
  runMigrations,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@compas/store&quot;</span>;

mainFn(<span class="hljs-keyword">import</span>.meta, main);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params">logger</span>) </span>{
  <span class="hljs-keyword">const</span> sql = newPostgresConnection({});
  <span class="hljs-keyword">const</span> mc = <span class="hljs-keyword">await</span> newMigrateContext(sql);
  logger.info(getMigrationsToBeApplied(mc) || <span class="hljs-string">&quot;No migrations to be applied.&quot;</span>);

  <span class="hljs-keyword">await</span> runMigrations(mc);

  <span class="hljs-keyword">await</span> sql.end();
}
</code></pre>
<h3 id="general-notes">General notes</h3>
<p>To calculate if a repeatable migration needs to run again, a sha1 is calculated
and stored in the database.</p>
<p>Migration namespaces shouldn&#39;t resolve in a graph. For example in the following
example you would get a hard crash when calling <code>newMigrateContext</code></p>
<pre><code class="language-text">// node_modules/A/migrations/namespaces.txt
B
// node_modules/B/migrations/namespaces.txt
C
// node_modules/C/migrations/namespaces.txt
A
</code></pre>
<p>The migration order is dependent on the following:</p>
<ul>
<li>An <code>import</code>-ed namespace will run first</li>
<li>The numbers in migration files are sorted ascending per namespace.</li>
</ul>
<p>The contents of the <code>migrations</code> table are applied to the on disk state. So if
you delete previous migrations nothing should fail.</p>
<p>All migrations run in a transaction. To escape from that put
<code>-- disable auto transaction</code> in the file.</p>
<h2 id="files">Files</h2>
<p>@lbu/store also provides a way to store files in S3 and keeping a reference to
the file in Postgres. This is not designed to be strict about things. The user
should do checks if the user may access or not.</p>
<p>Some features:</p>
<ul>
<li>Multiple buckets supported</li>
<li>Create and &#39;overwrite&#39; files</li>
<li>Get file info, file stream or partial file stream</li>
<li>Delete files</li>
<li>Sync deleted files to the s3 bucket</li>
</ul>
<h2 id="filecache">FileCache</h2>
<h2 id="sessionstore">SessionStore</h2>
<h2 id="jobqueue">JobQueue</h2>
<p>@lbu/store also comes with a Postgres backed queue implementation. The queue
supports the following:</p>
<ul>
<li>First In, First Out job handling</li>
<li>Prioritize jobs</li>
<li>Schedule jobs for execution in the future</li>
<li>Run workers for specific jobs</li>
</ul>
<p>Example usage:</p>
<pre><code class="language-javascript">mainFn(<span class="hljs-keyword">import</span>.meta, main);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> sql = <span class="hljs-keyword">await</span> newPostgresConnection();

  <span class="hljs-keyword">const</span> jobHandler = <span class="hljs-keyword">async</span> (sql, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(data.name); <span class="hljs-comment">// &quot;myJob&quot;</span>

    <span class="hljs-comment">// simulate work</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(r, <span class="hljs-number">100</span>));
  };

  <span class="hljs-comment">// parallelCount shouldn&#x27;t be higher than Postgres pool size</span>
  <span class="hljs-keyword">const</span> queueWorker = <span class="hljs-keyword">new</span> JobQueueWorker(sql, <span class="hljs-string">&quot;myJob&quot;</span>, {
    <span class="hljs-attr">parallelCount</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">pollInterval</span>: <span class="hljs-number">1500</span>,
    <span class="hljs-attr">handler</span>: jobHandler,
  });

  <span class="hljs-comment">// Start queue</span>
  queueWorker.start();

  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Get current queue size</span>
    queueWorker.pendingQueueSize().then(<span class="hljs-function">(<span class="hljs-params">{ pendingCount, scheduledCount }</span>) =&gt;</span> {
      log.info({ pendingCount, scheduledCount });
    });
  }, <span class="hljs-number">1500</span>);

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// running jobs are not cancelled</span>
    <span class="hljs-comment">// but no new job is started</span>
    queueWorker.stop();
  }, <span class="hljs-number">5000</span>);

  <span class="hljs-comment">// By default uses &quot;myJob&quot; as name</span>
  <span class="hljs-keyword">await</span> queueWorker.addJob({ <span class="hljs-attr">data</span>: {} });

  <span class="hljs-comment">// Items with a lower priority value are prioritized, defaults to 0</span>
  <span class="hljs-keyword">await</span> queueWorker.addJob({ <span class="hljs-attr">priority</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">data</span>: {} });

  <span class="hljs-comment">// Add job with a different name</span>
  <span class="hljs-keyword">await</span> queueWorker.addJob({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;otherJob&quot;</span>, <span class="hljs-attr">data</span>: {} });

  <span class="hljs-comment">// Add job with scheduled time to run, defaults to immediately</span>
  <span class="hljs-keyword">const</span> scheduledAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  scheduledAt.setDate(scheduledAt.getDate() + <span class="hljs-number">1</span>); <span class="hljs-comment">// Tomorrow</span>
  <span class="hljs-keyword">await</span> queueWorker.addJob({ scheduledAt, <span class="hljs-attr">data</span>: {} });

  <span class="hljs-comment">// Returns a job id, so you can use it as a tracking id / use it as a foreign key</span>
  <span class="hljs-keyword">const</span> jobId = <span class="hljs-keyword">await</span> queueWorker.addJob({ <span class="hljs-attr">data</span>: {} });

  <span class="hljs-comment">// The same api is available in separate exported function, so you don&#x27;t have to pass the queueWorker around</span>
  <span class="hljs-keyword">const</span> otherJobId = <span class="hljs-keyword">await</span> addJobToQueue(sql, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myJob&quot;</span>, <span class="hljs-attr">data</span>: {} });

  <span class="hljs-comment">// Get the average time to completion for jobs</span>
  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  start.setDate(start.getDate() - <span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-keyword">const</span> average = <span class="hljs-keyword">await</span> queueWorker.averageTimeToCompletion(start, end);
}
</code></pre>
<h2 id="code-gen-and-structure">Code-gen and structure</h2>
<p>To reference to any of the postgres tables, or use any of the provided types,
this package exports its structure used for code generation with
<a href="/code-gen.md">@lbu/code-gen</a>.</p>
<p>This can be used as follows:</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { storeStructure } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@compas/store&quot;</span>;

<span class="hljs-comment">// setup app</span>
app.extend(storeStructure);

<span class="hljs-comment">// Use group &quot;store&quot; if you want all of it,</span>
<span class="hljs-comment">// Else use references like `T.reference(&quot;store&quot;, &quot;file)` so the generator will only include that type.</span>
</code></pre>

    </article>
    
    </main>
    <footer>
        <nav><a href="https://compasjs.com/index.html">Compas</a> > <a href="https://compasjs.com/raw/index.html">Old docs</a></nav>
    </footer>
    </body>
</html>
  